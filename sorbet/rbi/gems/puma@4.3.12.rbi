# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `puma` gem.
# Please instead update this file by running `bin/tapioca gem puma`.

# source://puma//lib/puma/accept_nonblock.rb#7
class OpenSSL::SSL::SSLServer
  # source://puma//lib/puma/accept_nonblock.rb#9
  def accept_nonblock; end
end

# source://puma//lib/puma.rb#13
module Puma
  class << self
    # @return [Boolean]
    #
    # source://puma//lib/puma/detect.rb#6
    def jruby?; end

    # Thread name is new in Ruby 2.3
    #
    # source://puma//lib/puma.rb#27
    def set_thread_name(name); end

    # source://puma//lib/puma.rb#22
    def stats; end

    # source://puma//lib/puma.rb#18
    def stats_object=(val); end

    # @return [Boolean]
    #
    # source://puma//lib/puma/detect.rb#12
    def windows?; end
  end
end

# source://puma//lib/puma/binder.rb#11
class Puma::Binder
  include ::Puma::Const

  # @return [Binder] a new instance of Binder
  #
  # source://puma//lib/puma/binder.rb#16
  def initialize(events); end

  # source://puma//lib/puma/binder.rb#254
  def add_ssl_listener(host, port, ctx, optimize_for_latency = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # Tell the server to listen on host +host+, port +port+.
  # If +optimize_for_latency+ is true (the default) then clients connecting
  # will be optimized for latency over throughput.
  #
  # +backlog+ indicates how many unaccepted connections the kernel should
  # allow to accumulate before returning connection refused.
  #
  # source://puma//lib/puma/binder.rb#220
  def add_tcp_listener(host, port, optimize_for_latency = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # Tell the server to listen on +path+ as a UNIX domain socket.
  #
  # source://puma//lib/puma/binder.rb#307
  def add_unix_listener(path, umask = T.unsafe(nil), mode = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # source://puma//lib/puma/binder.rb#52
  def close; end

  # source://puma//lib/puma/binder.rb#362
  def close_listeners; end

  # source://puma//lib/puma/binder.rb#372
  def close_unix_paths; end

  # Returns the value of attribute connected_port.
  #
  # source://puma//lib/puma/binder.rb#241
  def connected_port; end

  # source://puma//lib/puma/binder.rb#48
  def env(sock); end

  # source://puma//lib/puma/binder.rb#56
  def import_from_env; end

  # source://puma//lib/puma/binder.rb#285
  def inherit_ssl_listener(fd, ctx); end

  # source://puma//lib/puma/binder.rb#243
  def inherit_tcp_listener(host, port, fd); end

  # source://puma//lib/puma/binder.rb#345
  def inherit_unix_listener(path, fd); end

  # Returns the value of attribute ios.
  #
  # source://puma//lib/puma/binder.rb#46
  def ios; end

  # source://puma//lib/puma/binder.rb#207
  def loopback_addresses; end

  # source://puma//lib/puma/binder.rb#89
  def parse(binds, logger); end

  # source://puma//lib/puma/binder.rb#376
  def redirects_for_restart; end
end

# source://puma//lib/puma/binder.rb#14
Puma::Binder::RACK_VERSION = T.let(T.unsafe(nil), Array)

# An instance of this class represents a unique request from a client.
# For example, this could be a web request from a browser or from CURL.
#
# An instance of `Puma::Client` can be used as if it were an IO object
# by the reactor. The reactor is expected to call `#to_io`
# on any non-IO objects it polls. For example, nio4r internally calls
# `IO::try_convert` (which may call `#to_io`) when a new socket is
# registered.
#
# Instances of this class are responsible for knowing if
# the header and body are fully buffered via the `try_to_finish` method.
# They can be used to "time out" a response via the `timeout_at` reader.
#
# source://puma//lib/puma/client.rb#41
class Puma::Client
  include ::Puma::Const
  extend ::Forwardable

  # @return [Client] a new instance of Client
  #
  # source://puma//lib/puma/client.rb#62
  def initialize(io, env = T.unsafe(nil)); end

  # Returns the value of attribute body.
  #
  # source://puma//lib/puma/client.rb#95
  def body; end

  # For the hijack protocol (allows us to just put the Client object
  # into the env)
  #
  # source://puma//lib/puma/client.rb#110
  def call; end

  # source://puma//lib/puma/client.rb#159
  def close; end

  # source://forwardable/1.3.1/forwardable.rb#226
  def closed?(*args, &block); end

  # source://puma//lib/puma/client.rb#252
  def eagerly_finish; end

  # Returns the value of attribute env.
  #
  # source://puma//lib/puma/client.rb#95
  def env; end

  # IS_JRUBY
  #
  # source://puma//lib/puma/client.rb#259
  def finish; end

  # Returns the value of attribute hijacked.
  #
  # source://puma//lib/puma/client.rb#95
  def hijacked; end

  # source://puma//lib/puma/client.rb#115
  def in_data_phase; end

  # source://puma//lib/puma/client.rb#104
  def inspect; end

  # Returns the value of attribute io.
  #
  # source://puma//lib/puma/client.rb#95
  def io; end

  # source://puma//lib/puma/client.rb#274
  def peerip; end

  # Sets the attribute peerip
  #
  # @param value the value to set the attribute peerip to.
  #
  # source://puma//lib/puma/client.rb#98
  def peerip=(_arg0); end

  # Returns the value of attribute ready.
  #
  # source://puma//lib/puma/client.rb#95
  def ready; end

  # Returns the value of attribute remote_addr_header.
  #
  # source://puma//lib/puma/client.rb#100
  def remote_addr_header; end

  # Sets the attribute remote_addr_header
  #
  # @param value the value to set the attribute remote_addr_header to.
  #
  # source://puma//lib/puma/client.rb#100
  def remote_addr_header=(_arg0); end

  # source://puma//lib/puma/client.rb#123
  def reset(fast_check = T.unsafe(nil)); end

  # source://puma//lib/puma/client.rb#119
  def set_timeout(val); end

  # Returns the value of attribute tempfile.
  #
  # source://puma//lib/puma/client.rb#95
  def tempfile; end

  # Returns the value of attribute timeout_at.
  #
  # source://puma//lib/puma/client.rb#95
  def timeout_at; end

  # Returns the value of attribute to_io.
  #
  # source://puma//lib/puma/client.rb#95
  def to_io; end

  # source://puma//lib/puma/client.rb#167
  def try_to_finish; end

  # source://puma//lib/puma/client.rb#267
  def write_error(status_code); end

  private

  # source://puma//lib/puma/client.rb#460
  def decode_chunk(chunk); end

  # source://puma//lib/puma/client.rb#369
  def read_body; end

  # source://puma//lib/puma/client.rb#414
  def read_chunked_body; end

  # source://puma//lib/puma/client.rb#549
  def set_ready; end

  # source://puma//lib/puma/client.rb#288
  def setup_body; end

  # source://puma//lib/puma/client.rb#439
  def setup_chunked_body(body); end

  # source://puma//lib/puma/client.rb#456
  def write_chunk(str); end
end

# this tests all values but the last, which must be chunked
#
# source://puma//lib/puma/client.rb#44
Puma::Client::ALLOWED_TRANSFER_ENCODING = T.let(T.unsafe(nil), Array)

# chunked body validation
#
# source://puma//lib/puma/client.rb#47
Puma::Client::CHUNK_SIZE_INVALID = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/client.rb#48
Puma::Client::CHUNK_VALID_ENDING = T.let(T.unsafe(nil), String)

# Content-Length header value validation
#
# source://puma//lib/puma/client.rb#51
Puma::Client::CONTENT_LENGTH_VALUE_INVALID = T.let(T.unsafe(nil), Regexp)

# The object used for a request with no body. All requests with
# no body share this one object since it has no state.
#
# source://puma//lib/puma/client.rb#57
Puma::Client::EmptyBody = T.let(T.unsafe(nil), Puma::NullIO)

# source://puma//lib/puma/client.rb#53
Puma::Client::TE_ERR_MSG = T.let(T.unsafe(nil), String)

# This class is instantiated by the `Puma::Launcher` and used
# to boot and serve a Ruby application when puma "workers" are needed
# i.e. when using multi-processes. For example `$ puma -w 5`
#
# At the core of this class is running an instance of `Puma::Server` which
# gets created via the `start_server` method from the `Puma::Runner` class
# that this inherits from.
#
# An instance of this class will spawn the number of processes passed in
# via the `spawn_workers` method call. Each worker will have it's own
# instance of a `Puma::Server`.
#
# source://puma//lib/puma/cluster.rb#21
class Puma::Cluster < ::Puma::Runner
  # @return [Cluster] a new instance of Cluster
  #
  # source://puma//lib/puma/cluster.rb#22
  def initialize(cli, events); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster.rb#178
  def all_workers_booted?; end

  # source://puma//lib/puma/cluster.rb#182
  def check_workers(force = T.unsafe(nil)); end

  # source://puma//lib/puma/cluster.rb#156
  def cull_workers; end

  # source://puma//lib/puma/cluster.rb#340
  def halt; end

  # source://puma//lib/puma/cluster.rb#171
  def next_worker_index; end

  # source://puma//lib/puma/cluster.rb#319
  def phased_restart; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster.rb#360
  def preload?; end

  # source://puma//lib/puma/cluster.rb#59
  def redirect_io; end

  # source://puma//lib/puma/cluster.rb#345
  def reload_worker_directory; end

  # source://puma//lib/puma/cluster.rb#314
  def restart; end

  # source://puma//lib/puma/cluster.rb#402
  def run; end

  # We do this in a separate method to keep the lambda scope
  # of the signals handlers as small as possible.
  #
  # source://puma//lib/puma/cluster.rb#366
  def setup_signals; end

  # source://puma//lib/puma/cluster.rb#128
  def spawn_workers; end

  # source://puma//lib/puma/cluster.rb#48
  def start_phased_restart; end

  # Inside of a child process, this will return all zeroes, as @workers is only populated in
  # the master process.
  #
  # source://puma//lib/puma/cluster.rb#353
  def stats; end

  # source://puma//lib/puma/cluster.rb#328
  def stop; end

  # source://puma//lib/puma/cluster.rb#333
  def stop_blocked; end

  # source://puma//lib/puma/cluster.rb#33
  def stop_workers; end

  # source://puma//lib/puma/cluster.rb#227
  def wakeup!; end

  # source://puma//lib/puma/cluster.rb#237
  def worker(index, master); end

  private

  # loops thru @workers, removing workers that exited, and calling
  # `#term` if needed
  #
  # source://puma//lib/puma/cluster.rb#539
  def wait_workers; end
end

# source://puma//lib/puma/cluster.rb#65
class Puma::Cluster::Worker
  # @return [Worker] a new instance of Worker
  #
  # source://puma//lib/puma/cluster.rb#66
  def initialize(idx, pid, phase, options); end

  # source://puma//lib/puma/cluster.rb#86
  def boot!; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster.rb#82
  def booted?; end

  # source://puma//lib/puma/cluster.rb#122
  def hup; end

  # Returns the value of attribute index.
  #
  # source://puma//lib/puma/cluster.rb#80
  def index; end

  # source://puma//lib/puma/cluster.rb#117
  def kill; end

  # Returns the value of attribute last_checkin.
  #
  # source://puma//lib/puma/cluster.rb#80
  def last_checkin; end

  # Returns the value of attribute last_status.
  #
  # source://puma//lib/puma/cluster.rb#80
  def last_status; end

  # Returns the value of attribute phase.
  #
  # source://puma//lib/puma/cluster.rb#80
  def phase; end

  # Returns the value of attribute pid.
  #
  # source://puma//lib/puma/cluster.rb#80
  def pid; end

  # source://puma//lib/puma/cluster.rb#95
  def ping!(status); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster.rb#100
  def ping_timeout?(which); end

  # Returns the value of attribute signal.
  #
  # source://puma//lib/puma/cluster.rb#80
  def signal; end

  # Returns the value of attribute started_at.
  #
  # source://puma//lib/puma/cluster.rb#80
  def started_at; end

  # source://puma//lib/puma/cluster.rb#104
  def term; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster.rb#91
  def term?; end
end

# source://puma//lib/puma/client.rb#24
class Puma::ConnectionError < ::RuntimeError; end

# Frequently used constants when constructing requests or responses.  Many times
# the constant just refers to a string with the same contents.  Using these constants
# gave about a 3% to 10% performance improvement over using the strings directly.
#
# The constants are frozen because Hash#[]= when called with a String key dups
# the String UNLESS the String is frozen. This saves us therefore 2 object
# allocations when creating the env hash later.
#
# While Puma does try to emulate the CGI/1.2 protocol, it does not use the REMOTE_IDENT,
# REMOTE_USER, or REMOTE_HOST parameters since those are either a security problem or
# too taxing on performance.
#
# source://puma//lib/puma/const.rb#101
module Puma::Const; end

# source://puma//lib/puma/const.rb#187
Puma::Const::CGI_VER = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#228
Puma::Const::CHUNKED = T.let(T.unsafe(nil), String)

# The basic max request size we'll try to read.
#
# source://puma//lib/puma/const.rb#154
Puma::Const::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#214
Puma::Const::CLOSE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#226
Puma::Const::CLOSE_CHUNKED = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#104
Puma::Const::CODE_NAME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#230
Puma::Const::COLON = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#222
Puma::Const::CONNECTION_CLOSE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#223
Puma::Const::CONNECTION_KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#132
Puma::Const::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#217
Puma::Const::CONTENT_LENGTH2 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#218
Puma::Const::CONTENT_LENGTH_S = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#208
Puma::Const::CONTINUE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#239
Puma::Const::EARLY_HINTS = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#138
Puma::Const::ERROR_RESPONSE = T.let(T.unsafe(nil), Hash)

# source://puma//lib/puma/const.rb#107
Puma::Const::FAST_TRACK_KA_TIMEOUT = T.let(T.unsafe(nil), Float)

# The default number of seconds to wait until we get the first data
# for the request
#
# source://puma//lib/puma/const.rb#115
Puma::Const::FIRST_DATA_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#186
Puma::Const::GATEWAY_INTERFACE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#190
Puma::Const::HALT_COMMAND = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#164
Puma::Const::HEAD = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#236
Puma::Const::HIJACK = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#237
Puma::Const::HIJACK_IO = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#235
Puma::Const::HIJACK_P = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#200
Puma::Const::HTTP = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#201
Puma::Const::HTTPS = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#203
Puma::Const::HTTPS_KEY = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#212
Puma::Const::HTTP_10_200 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#183
Puma::Const::HTTP_11 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#210
Puma::Const::HTTP_11_100 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#211
Puma::Const::HTTP_11_200 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#206
Puma::Const::HTTP_CONNECTION = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#207
Puma::Const::HTTP_EXPECT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#175
Puma::Const::HTTP_HOST = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#233
Puma::Const::HTTP_INJECTION_REGEX = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/const.rb#205
Puma::Const::HTTP_VERSION = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#168
Puma::Const::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#171
Puma::Const::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#170
Puma::Const::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#169
Puma::Const::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#215
Puma::Const::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# ETag is based on the apache standard of hex mtime-size-inode (inode is 0 on win32)
#
# source://puma//lib/puma/const.rb#166
Puma::Const::LINE_END = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#178
Puma::Const::LOCALHOST = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#180
Puma::Const::LOCALHOST_ADDR = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#179
Puma::Const::LOCALHOST_IP = T.let(T.unsafe(nil), String)

# Maximum request body size before it is moved out of memory and into a tempfile for reading.
#
# source://puma//lib/puma/const.rb#161
Puma::Const::MAX_BODY = T.let(T.unsafe(nil), Integer)

# How many requests to attempt inline before sending a client back to
# the reactor to be subject to normal ordering. The idea here is that
# we amortize the cost of going back to the reactor for a well behaved
# but very "greedy" client across 10 requests. This prevents a not
# well behaved client from monopolizing the thread forever.
#
# source://puma//lib/puma/const.rb#126
Puma::Const::MAX_FAST_INLINE = T.let(T.unsafe(nil), Integer)

# This is the maximum header that is allowed before a client is booted.  The parser detects
# this, but we'd also like to do this as well.
#
# source://puma//lib/puma/const.rb#158
Puma::Const::MAX_HEADER = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#232
Puma::Const::NEWLINE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#134
Puma::Const::PATH_INFO = T.let(T.unsafe(nil), String)

# The default number of seconds for another request within a persistent
# session.
#
# source://puma//lib/puma/const.rb#111
Puma::Const::PERSISTENT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#177
Puma::Const::PORT_443 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#176
Puma::Const::PORT_80 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#197
Puma::Const::PUMA_CONFIG = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#198
Puma::Const::PUMA_PEERCERT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#105
Puma::Const::PUMA_SERVER_STRING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#196
Puma::Const::PUMA_SOCKET = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#136
Puma::Const::PUMA_TMP_BASE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#103
Puma::Const::PUMA_VERSION = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#131
Puma::Const::QUERY_STRING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#195
Puma::Const::RACK_AFTER_REPLY = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#193
Puma::Const::RACK_INPUT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#194
Puma::Const::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#167
Puma::Const::REMOTE_ADDR = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#163
Puma::Const::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#130
Puma::Const::REQUEST_PATH = T.let(T.unsafe(nil), String)

# The original URI requested by the client.
#
# source://puma//lib/puma/const.rb#129
Puma::Const::REQUEST_URI = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#191
Puma::Const::RESTART_COMMAND = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#173
Puma::Const::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#174
Puma::Const::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#182
Puma::Const::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#185
Puma::Const::SERVER_SOFTWARE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#189
Puma::Const::STOP_COMMAND = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#219
Puma::Const::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#220
Puma::Const::TRANSFER_ENCODING2 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#225
Puma::Const::TRANSFER_ENCODING_CHUNKED = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#103
Puma::Const::VERSION = T.let(T.unsafe(nil), String)

# Mininum interval to checks worker health
#
# source://puma//lib/puma/const.rb#242
Puma::Const::WORKER_CHECK_INTERVAL = T.let(T.unsafe(nil), Integer)

# How long to wait when getting some write blocking on the socket when
# sending data back
#
# source://puma//lib/puma/const.rb#119
Puma::Const::WRITE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# The default implement of an event sink object used by Server
# for when certain kinds of events occur in the life of the server.
#
# The methods available are the events that the Server fires.
#
# source://puma//lib/puma/events.rb#13
class Puma::Events
  include ::Puma::Const

  # Create an Events object that prints to +stdout+ and +stderr+.
  #
  # @return [Events] a new instance of Events
  #
  # source://puma//lib/puma/events.rb#30
  def initialize(stdout, stderr); end

  # source://puma//lib/puma/events.rb#76
  def debug(str); end

  # Write +str+ to +@stderr+
  #
  # source://puma//lib/puma/events.rb#82
  def error(str); end

  # Fire callbacks for the named hook
  #
  # source://puma//lib/puma/events.rb#48
  def fire(hook, *args); end

  # source://puma//lib/puma/events.rb#134
  def fire_on_booted!; end

  # source://puma//lib/puma/events.rb#87
  def format(str); end

  # Returns the value of attribute formatter.
  #
  # source://puma//lib/puma/events.rb#44
  def formatter; end

  # Sets the attribute formatter
  #
  # @param value the value to set the attribute formatter to.
  #
  # source://puma//lib/puma/events.rb#44
  def formatter=(_arg0); end

  # Write +str+ to +@stdout+
  #
  # source://puma//lib/puma/events.rb#68
  def log(str); end

  # source://puma//lib/puma/events.rb#130
  def on_booted(&block); end

  # An HTTP parse error has occurred.
  # +server+ is the Server object, +env+ the request, and +error+ a
  # parsing exception.
  #
  # source://puma//lib/puma/events.rb#95
  def parse_error(server, env, error); end

  # Register a callback for a given hook
  #
  # source://puma//lib/puma/events.rb#54
  def register(hook, obj = T.unsafe(nil), &blk); end

  # An SSL error has occurred.
  # +server+ is the Server object, +peeraddr+ peer address, +peercert+
  # any peer certificate (if present), and +error+ an exception object.
  #
  # source://puma//lib/puma/events.rb#106
  def ssl_error(server, peeraddr, peercert, error); end

  # Returns the value of attribute stderr.
  #
  # source://puma//lib/puma/events.rb#43
  def stderr; end

  # Returns the value of attribute stdout.
  #
  # source://puma//lib/puma/events.rb#43
  def stdout; end

  # An unknown error has occurred.
  # +server+ is the Server object, +error+ an exception object,
  # +kind+ some additional info, and +env+ the request.
  #
  # source://puma//lib/puma/events.rb#115
  def unknown_error(server, error, kind = T.unsafe(nil), env = T.unsafe(nil)); end

  # source://puma//lib/puma/events.rb#72
  def write(str); end

  class << self
    # source://puma//lib/puma/events.rb#151
    def null; end

    # source://puma//lib/puma/events.rb#147
    def stdio; end

    # Returns an Events object which writes its status to 2 StringIO
    # objects.
    #
    # source://puma//lib/puma/events.rb#143
    def strings; end
  end
end

# source://puma//lib/puma/events.rb#138
Puma::Events::DEFAULT = T.let(T.unsafe(nil), Puma::Events)

# source://puma//lib/puma/events.rb#14
class Puma::Events::DefaultFormatter
  # source://puma//lib/puma/events.rb#15
  def call(str); end
end

# source://puma//lib/puma/events.rb#20
class Puma::Events::PidFormatter
  # source://puma//lib/puma/events.rb#21
  def call(str); end
end

# Every standard HTTP code mapped to the appropriate message.
# Generated with:
# curl -s https://www.iana.org/assignments/http-status-codes/http-status-codes-1.csv | \
#   ruby -ne 'm = /^(\d{3}),(?!Unassigned|\(Unused\))([^,]+)/.match($_) and \
#             puts "#{m[1]} => \x27#{m[2].strip}\x27,"'
#
# source://puma//lib/puma/const.rb#18
Puma::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

class Puma::HttpParser
  def initialize; end

  def body; end
  def error?; end
  def execute(_arg0, _arg1, _arg2); end
  def finish; end
  def finished?; end
  def nread; end
  def reset; end
end

class Puma::HttpParserError < ::IOError; end

# source://puma//lib/puma/client.rb#26
class Puma::HttpParserError501 < ::IOError; end

class Puma::IOBuffer
  def <<(_arg0); end
  def append(*_arg0); end
  def capacity; end
  def reset; end
  def to_s; end
  def to_str; end
  def used; end
end

# source://puma//lib/puma/detect.rb#4
Puma::IS_JRUBY = T.let(T.unsafe(nil), T.untyped)

# source://puma//lib/puma/detect.rb#10
Puma::IS_WINDOWS = T.let(T.unsafe(nil), T.untyped)

# Puma::Launcher is the single entry point for starting a Puma server based on user
# configuration. It is responsible for taking user supplied arguments and resolving them
# with configuration in `config/puma.rb` or `config/puma/<env>.rb`.
#
# It is responsible for either launching a cluster of Puma workers or a single
# puma server.
#
# source://puma//lib/puma/launcher.rb#17
class Puma::Launcher
  # Returns an instance of Launcher
  #
  # +conf+ A Puma::Configuration object indicating how to run the server.
  #
  # +launcher_args+ A Hash that currently has one required key `:events`,
  # this is expected to hold an object similar to an `Puma::Events.stdio`,
  # this object will be responsible for broadcasting Puma's internal state
  # to a logging destination. An optional key `:argv` can be supplied,
  # this should be an array of strings, these arguments are re-used when
  # restarting the puma server.
  #
  # Examples:
  #
  #   conf = Puma::Configuration.new do |user_config|
  #     user_config.threads 1, 10
  #     user_config.app do |env|
  #       [200, {}, ["hello world"]]
  #     end
  #   end
  #   Puma::Launcher.new(conf, events: Puma::Events.stdio).run
  #
  # @return [Launcher] a new instance of Launcher
  #
  # source://puma//lib/puma/launcher.rb#43
  def initialize(conf, launcher_args = T.unsafe(nil)); end

  # Returns the value of attribute binder.
  #
  # source://puma//lib/puma/launcher.rb#95
  def binder; end

  # source://puma//lib/puma/launcher.rb#204
  def close_binder_listeners; end

  # Returns the value of attribute config.
  #
  # source://puma//lib/puma/launcher.rb#95
  def config; end

  # Return which tcp port the launcher is using, if it's using TCP
  #
  # source://puma//lib/puma/launcher.rb#191
  def connected_port; end

  # Delete the configured pidfile
  #
  # source://puma//lib/puma/launcher.rb#121
  def delete_pidfile; end

  # Returns the value of attribute events.
  #
  # source://puma//lib/puma/launcher.rb#95
  def events; end

  # Begin async shutdown of the server
  #
  # source://puma//lib/puma/launcher.rb#127
  def halt; end

  # Returns the value of attribute options.
  #
  # source://puma//lib/puma/launcher.rb#95
  def options; end

  # Begin a phased restart if supported
  #
  # source://puma//lib/puma/launcher.rb#145
  def phased_restart; end

  # Begin async restart of the server
  #
  # source://puma//lib/puma/launcher.rb#139
  def restart; end

  # source://puma//lib/puma/launcher.rb#195
  def restart_args; end

  # Returns the value of attribute restart_dir.
  #
  # source://puma//lib/puma/launcher.rb#95
  def restart_dir; end

  # Run the server. This blocks until the server is stopped
  #
  # source://puma//lib/puma/launcher.rb#154
  def run; end

  # Return stats about the server
  #
  # source://puma//lib/puma/launcher.rb#98
  def stats; end

  # Begin async shutdown of the server gracefully
  #
  # source://puma//lib/puma/launcher.rb#133
  def stop; end

  # Write a state file that can be used by pumactl to control
  # the server
  #
  # source://puma//lib/puma/launcher.rb#104
  def write_state; end

  private

  # @return [Boolean]
  #
  # source://puma//lib/puma/launcher.rb#311
  def clustered?; end

  # source://puma//lib/puma/launcher.rb#249
  def dependencies_and_files_to_require_after_prune; end

  # source://puma//lib/puma/launcher.rb#356
  def environment; end

  # source://puma//lib/puma/launcher.rb#259
  def extra_runtime_deps_directories; end

  # source://puma//lib/puma/launcher.rb#364
  def generate_restart_data; end

  # source://puma//lib/puma/launcher.rb#320
  def graceful_stop; end

  # source://puma//lib/puma/launcher.rb#307
  def log(str); end

  # source://puma//lib/puma/launcher.rb#326
  def log_thread_status; end

  # source://puma//lib/puma/launcher.rb#277
  def prune_bundler; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/launcher.rb#360
  def prune_bundler?; end

  # source://puma//lib/puma/launcher.rb#270
  def puma_wild_location; end

  # source://puma//lib/puma/launcher.rb#223
  def reload_worker_directory; end

  # source://puma//lib/puma/launcher.rb#303
  def require_paths_for_gem(gem_spec); end

  # source://puma//lib/puma/launcher.rb#468
  def require_rubygems_min_version!(min_version, feature); end

  # source://puma//lib/puma/launcher.rb#227
  def restart!; end

  # source://puma//lib/puma/launcher.rb#341
  def set_process_title; end

  # source://puma//lib/puma/launcher.rb#351
  def set_rack_environment; end

  # source://puma//lib/puma/launcher.rb#409
  def setup_signals; end

  # source://puma//lib/puma/launcher.rb#299
  def spec_for_gem(gem_name); end

  # source://puma//lib/puma/launcher.rb#345
  def title; end

  # @raise [UnsupportedOption]
  #
  # source://puma//lib/puma/launcher.rb#315
  def unsupported(str); end

  # If configured, write the pid of the current process out
  # to a file.
  #
  # source://puma//lib/puma/launcher.rb#212
  def write_pid; end
end

# source://puma//lib/puma/launcher.rb#18
Puma::Launcher::KEYS_NOT_TO_PERSIST_IN_STATE = T.let(T.unsafe(nil), Array)

# source://puma//lib/puma/minissl.rb#9
module Puma::MiniSSL
  class << self
    def check; end
  end
end

# source://puma//lib/puma/minissl.rb#177
class Puma::MiniSSL::Context
  # @return [Context] a new instance of Context
  #
  # source://puma//lib/puma/minissl.rb#181
  def initialize; end

  # Returns the value of attribute ca.
  #
  # source://puma//lib/puma/minissl.rb#205
  def ca; end

  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#218
  def ca=(ca); end

  # Returns the value of attribute cert.
  #
  # source://puma//lib/puma/minissl.rb#204
  def cert; end

  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#213
  def cert=(cert); end

  # source://puma//lib/puma/minissl.rb#223
  def check; end

  # non-jruby Context properties
  #
  # source://puma//lib/puma/minissl.rb#203
  def key; end

  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#208
  def key=(key); end

  # Returns the value of attribute no_tlsv1.
  #
  # source://puma//lib/puma/minissl.rb#179
  def no_tlsv1; end

  # disables TLSv1
  #
  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#230
  def no_tlsv1=(tlsv1); end

  # Returns the value of attribute no_tlsv1_1.
  #
  # source://puma//lib/puma/minissl.rb#179
  def no_tlsv1_1; end

  # disables TLSv1 and TLSv1.1.  Overrides `#no_tlsv1=`
  #
  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#236
  def no_tlsv1_1=(tlsv1_1); end

  # Returns the value of attribute ssl_cipher_filter.
  #
  # source://puma//lib/puma/minissl.rb#206
  def ssl_cipher_filter; end

  # Sets the attribute ssl_cipher_filter
  #
  # @param value the value to set the attribute ssl_cipher_filter to.
  #
  # source://puma//lib/puma/minissl.rb#206
  def ssl_cipher_filter=(_arg0); end

  # Returns the value of attribute verify_mode.
  #
  # source://puma//lib/puma/minissl.rb#178
  def verify_mode; end

  # Sets the attribute verify_mode
  #
  # @param value the value to set the attribute verify_mode to.
  #
  # source://puma//lib/puma/minissl.rb#178
  def verify_mode=(_arg0); end
end

# source://puma//lib/puma/minissl/context_builder.rb#3
class Puma::MiniSSL::ContextBuilder
  # @return [ContextBuilder] a new instance of ContextBuilder
  #
  # source://puma//lib/puma/minissl/context_builder.rb#4
  def initialize(params, events); end

  # source://puma//lib/puma/minissl/context_builder.rb#12
  def context; end

  private

  # Returns the value of attribute events.
  #
  # source://puma//lib/puma/minissl/context_builder.rb#73
  def events; end

  # Returns the value of attribute params.
  #
  # source://puma//lib/puma/minissl/context_builder.rb#73
  def params; end
end

class Puma::MiniSSL::Engine
  def extract; end
  def init?; end
  def inject(_arg0); end
  def peercert; end
  def read; end
  def shutdown; end
  def write(_arg0); end

  class << self
    def client; end
    def server(_arg0); end
  end
end

Puma::MiniSSL::OPENSSL_LIBRARY_VERSION = T.let(T.unsafe(nil), String)
Puma::MiniSSL::OPENSSL_NO_SSL3 = T.let(T.unsafe(nil), TrueClass)
Puma::MiniSSL::OPENSSL_NO_TLS1 = T.let(T.unsafe(nil), FalseClass)
Puma::MiniSSL::OPENSSL_NO_TLS1_1 = T.let(T.unsafe(nil), FalseClass)
Puma::MiniSSL::OPENSSL_VERSION = T.let(T.unsafe(nil), String)
class Puma::MiniSSL::SSLError < ::StandardError; end

# source://puma//lib/puma/minissl.rb#247
class Puma::MiniSSL::Server
  # @return [Server] a new instance of Server
  #
  # source://puma//lib/puma/minissl.rb#248
  def initialize(socket, ctx); end

  # source://puma//lib/puma/minissl.rb#257
  def accept; end

  # source://puma//lib/puma/minissl.rb#265
  def accept_nonblock; end

  # source://puma//lib/puma/minissl.rb#273
  def close; end

  # source://puma//lib/puma/minissl.rb#253
  def to_io; end
end

# source://puma//lib/puma/minissl.rb#10
class Puma::MiniSSL::Socket
  # @return [Socket] a new instance of Socket
  #
  # source://puma//lib/puma/minissl.rb#11
  def initialize(socket, engine); end

  # source://puma//lib/puma/minissl.rb#84
  def <<(data); end

  # source://puma//lib/puma/minissl.rb#139
  def close; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/minissl.rb#21
  def closed?; end

  # source://puma//lib/puma/minissl.rb#42
  def engine_read_all; end

  # source://puma//lib/puma/minissl.rb#122
  def flush; end

  # source://puma//lib/puma/minissl.rb#155
  def peeraddr; end

  # source://puma//lib/puma/minissl.rb#159
  def peercert; end

  # source://puma//lib/puma/minissl.rb#126
  def read_and_drop(timeout = T.unsafe(nil)); end

  # source://puma//lib/puma/minissl.rb#50
  def read_nonblock(size, *_); end

  # source://puma//lib/puma/minissl.rb#25
  def readpartial(size); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/minissl.rb#135
  def should_drop_bytes?; end

  # source://puma//lib/puma/minissl.rb#84
  def syswrite(data); end

  # source://puma//lib/puma/minissl.rb#17
  def to_io; end

  # source://puma//lib/puma/minissl.rb#84
  def write(data); end

  # This is a temporary fix to deal with websockets code using
  # write_nonblock. The problem with implementing it properly
  # is that it means we'd have to have the ability to rewind
  # an engine because after we write+extract, the socket
  # write_nonblock call might raise an exception and later
  # code would pass the same data in, but the engine would think
  # it had already written the data in. So for the time being
  # (and since write blocking is quite rare), go ahead and actually
  # block in write_nonblock.
  #
  # source://puma//lib/puma/minissl.rb#118
  def write_nonblock(data, *_); end
end

# source://puma//lib/puma/minissl.rb#245
Puma::MiniSSL::VERIFY_FAIL_IF_NO_PEER_CERT = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/minissl.rb#243
Puma::MiniSSL::VERIFY_NONE = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/minissl.rb#244
Puma::MiniSSL::VERIFY_PEER = T.let(T.unsafe(nil), Integer)

# Provides an IO-like object that always appears to contain no data.
# Used as the value for rack.input when the request has no body.
#
# source://puma//lib/puma/null_io.rb#7
class Puma::NullIO
  # source://puma//lib/puma/null_io.rb#24
  def close; end

  # source://puma//lib/puma/null_io.rb#12
  def each; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/null_io.rb#31
  def eof?; end

  # source://puma//lib/puma/null_io.rb#8
  def gets; end

  # source://puma//lib/puma/null_io.rb#38
  def puts(*ary); end

  # Mimics IO#read with no data.
  #
  # source://puma//lib/puma/null_io.rb#17
  def read(count = T.unsafe(nil), _buffer = T.unsafe(nil)); end

  # source://puma//lib/puma/null_io.rb#21
  def rewind; end

  # source://puma//lib/puma/null_io.rb#27
  def size; end

  # source://puma//lib/puma/null_io.rb#35
  def sync=(v); end

  # source://puma//lib/puma/null_io.rb#41
  def write(*ary); end
end

# source://puma//lib/puma/plugin.rb#76
class Puma::Plugin
  # @return [Plugin] a new instance of Plugin
  #
  # source://puma//lib/puma/plugin.rb#107
  def initialize(loader); end

  # source://puma//lib/puma/plugin.rb#111
  def in_background(&blk); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/plugin.rb#115
  def workers_supported?; end

  class << self
    # source://puma//lib/puma/plugin.rb#97
    def create(&blk); end

    # source://puma//lib/puma/plugin.rb#90
    def extract_name(ary); end
  end
end

# Matches
#  "C:/Ruby22/lib/ruby/gems/2.2.0/gems/puma-3.0.1/lib/puma/plugin/tmp_restart.rb:3:in `<top (required)>'"
#  AS
#  C:/Ruby22/lib/ruby/gems/2.2.0/gems/puma-3.0.1/lib/puma/plugin/tmp_restart.rb
#
# source://puma//lib/puma/plugin.rb#81
Puma::Plugin::CALLER_FILE = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/plugin.rb#6
class Puma::PluginLoader
  # @return [PluginLoader] a new instance of PluginLoader
  #
  # source://puma//lib/puma/plugin.rb#7
  def initialize; end

  # @raise [UnknownPlugin]
  #
  # source://puma//lib/puma/plugin.rb#11
  def create(name); end

  # source://puma//lib/puma/plugin.rb#21
  def fire_starts(launcher); end
end

# source://puma//lib/puma/plugin.rb#30
class Puma::PluginRegistry
  # @return [PluginRegistry] a new instance of PluginRegistry
  #
  # source://puma//lib/puma/plugin.rb#31
  def initialize; end

  # source://puma//lib/puma/plugin.rb#60
  def add_background(blk); end

  # @raise [UnknownPlugin]
  #
  # source://puma//lib/puma/plugin.rb#40
  def find(name); end

  # source://puma//lib/puma/plugin.rb#64
  def fire_background; end

  # source://puma//lib/puma/plugin.rb#36
  def register(name, cls); end
end

# source://puma//lib/puma/plugin.rb#74
Puma::Plugins = T.let(T.unsafe(nil), Puma::PluginRegistry)

# Internal Docs, Not a public interface.
#
# The Reactor object is responsible for ensuring that a request has been
# completely received before it starts to be processed. This may be known as read buffering.
# If read buffering is not done, and no other read buffering is performed (such as by an application server
# such as nginx) then the application would be subject to a slow client attack.
#
# Each Puma "worker" process has its own Reactor. For example if you start puma with `$ puma -w 5` then
# it will have 5 workers and each worker will have it's own reactor.
#
# For a graphical representation of how the reactor works see [architecture.md](https://github.com/puma/puma/blob/master/docs/architecture.md#connection-pipeline).
#
# ## Reactor Flow
#
# A connection comes into a `Puma::Server` instance, it is then passed to a `Puma::Reactor` instance,
# which stores it in an array and waits for any of the connections to be ready for reading.
#
# The waiting/wake up is performed with nio4r, which will use the appropriate backend (libev, Java NIO or
# just plain IO#select). The call to `NIO::Selector#select` will "wake up" and
# return the references to any objects that caused it to "wake". The reactor
# then loops through each of these request objects, and sees if they're complete. If they
# have a full header and body then the reactor passes the request to a thread pool.
# Once in a thread pool, a "worker thread" can run the the application's Ruby code against the request.
#
# If the request is not complete, then it stays in the array, and the next time any
# data is written to that socket reference, then the loop is woken up and it is checked for completeness again.
#
# A detailed example is given in the docs for `run_internal` which is where the bulk
# of this logic lives.
#
# source://puma//lib/puma/reactor.rb#38
class Puma::Reactor
  # Creates an instance of Puma::Reactor
  #
  # The `server` argument is an instance of `Puma::Server`
  # that is used to write a response for "low level errors"
  # when there is an exception inside of the reactor.
  #
  # The `app_pool` is an instance of `Puma::ThreadPool`.
  # Once a request is fully formed (header and body are received)
  # it will be passed to the `app_pool`.
  #
  # @return [Reactor] a new instance of Reactor
  #
  # source://puma//lib/puma/reactor.rb#50
  def initialize(server, app_pool); end

  # This method adds a connection to the reactor
  #
  # Typically called by `Puma::Server` the value passed in
  # is usually a `Puma::Client` object that responds like an IO
  # object.
  #
  # The main body of the reactor loop is in `run_internal` and it
  # will sleep on `NIO::Selector#select`. When a new connection is added to the
  # reactor it cannot be added directly to the `sockets` array, because
  # the `NIO::Selector#select` will not be watching for it yet.
  #
  # Instead what needs to happen is that `NIO::Selector#select` needs to be woken up,
  # the contents of `@input` added to the `sockets` array, and then
  # another call to `NIO::Selector#select` needs to happen. Since the `Puma::Client`
  # object can be read immediately, it does not block, but instead returns
  # right away.
  #
  # This behavior is accomplished by writing to `@trigger` which wakes up
  # the `NIO::Selector#select` and then there is logic to detect the value of `*`,
  # pull the contents from `@input` and add them to the sockets array.
  #
  # If the object passed in has a timeout value in `timeout_at` then
  # it is added to a `@timeouts` array. This array is then re-arranged
  # so that the first element to timeout will be at the front of the
  # array. Then a value to sleep for is derived in the call to `calculate_sleep`
  #
  # source://puma//lib/puma/reactor.rb#374
  def add(c); end

  # The `calculate_sleep` sets the value that the `NIO::Selector#select` will
  # sleep for in the main reactor loop when no sockets are being written to.
  #
  # The values kept in `@timeouts` are sorted so that the first timeout
  # comes first in the array. When there are no timeouts the default timeout is used.
  #
  # Otherwise a sleep value is set that is the same as the amount of time it
  # would take for the first element to time out.
  #
  # If that value is in the past, then a sleep value of zero is used.
  #
  # source://puma//lib/puma/reactor.rb#335
  def calculate_sleep; end

  # Close all watched sockets and clear them from being watched
  #
  # source://puma//lib/puma/reactor.rb#382
  def clear!; end

  # source://puma//lib/puma/reactor.rb#302
  def run; end

  # source://puma//lib/puma/reactor.rb#309
  def run_in_thread; end

  # source://puma//lib/puma/reactor.rb#390
  def shutdown; end

  private

  # source://puma//lib/puma/reactor.rb#295
  def clear_monitor(mon); end

  # Until a request is added via the `add` method this method will internally
  # loop, waiting on the `sockets` array objects. The only object in this
  # array at first is the `@ready` IO object, which is the read end of a pipe
  # connected to `@trigger` object. When `@trigger` is written to, then the loop
  # will break on `NIO::Selector#select` and return an array.
  #
  # ## When a request is added:
  #
  # When the `add` method is called, an instance of `Puma::Client` is added to the `@input` array.
  # Next the `@ready` pipe is "woken" by writing a string of `"*"` to `@trigger`.
  #
  # When that happens, the internal loop stops blocking at `NIO::Selector#select` and returns a reference
  # to whatever "woke" it up. On the very first loop, the only thing in `sockets` is `@ready`.
  # When `@trigger` is written-to, the loop "wakes" and the `ready`
  # variable returns an array of arrays that looks like `[[#<IO:fd 10>], [], []]` where the
  # first IO object is the `@ready` object. This first array `[#<IO:fd 10>]`
  # is saved as a `reads` variable.
  #
  # The `reads` variable is iterated through. In the case that the object
  # is the same as the `@ready` input pipe, then we know that there was a `trigger` event.
  #
  # If there was a trigger event, then one byte of `@ready` is read into memory. In the case of the first request,
  # the reactor sees that it's a `"*"` value and the reactor adds the contents of `@input` into the `sockets` array.
  # The while then loop continues to iterate again, but now the `sockets` array contains a `Puma::Client` instance in addition
  # to the `@ready` IO object. For example: `[#<IO:fd 10>, #<Puma::Client:0x3fdc1103bee8 @ready=false>]`.
  #
  # Since the `Puma::Client` in this example has data that has not been read yet,
  # the `NIO::Selector#select` is immediately able to "wake" and read from the `Puma::Client`. At this point the
  # `ready` output looks like this: `[[#<Puma::Client:0x3fdc1103bee8 @ready=false>], [], []]`.
  #
  # Each element in the first entry is iterated over. The `Puma::Client` object is not
  # the `@ready` pipe, so the reactor checks to see if it has the full header and body with
  # the `Puma::Client#try_to_finish` method. If the full request has been sent,
  # then the request is passed off to the `@app_pool` thread pool so that a "worker thread"
  # can pick up the request and begin to execute application logic. This is done
  # via `@app_pool << c`. The `Puma::Client` is then removed from the `sockets` array.
  #
  # If the request body is not present then nothing will happen, and the loop will iterate
  # again. When the client sends more data to the socket the `Puma::Client` object will
  # wake up the `NIO::Selector#select` and it can again be checked to see if it's ready to be
  # passed to the thread pool.
  #
  # ## Time Out Case
  #
  # In addition to being woken via a write to one of the sockets the `NIO::Selector#select` will
  # periodically "time out" of the sleep. One of the functions of this is to check for
  # any requests that have "timed out". At the end of the loop it's checked to see if
  # the first element in the `@timeout` array has exceed its allowed time. If so,
  # the client object is removed from the timeout array, a 408 response is written.
  # Then its connection is closed, and the object is removed from the `sockets` array
  # that watches for new data.
  #
  # This behavior loops until all the objects that have timed out have been removed.
  #
  # Once all the timeouts have been processed, the next duration of the `NIO::Selector#select` sleep
  # will be set to be equal to the amount of time it will take for the next timeout to occur.
  # This calculation happens in `calculate_sleep`.
  #
  # source://puma//lib/puma/reactor.rb#130
  def run_internal; end
end

# source://puma//lib/puma/reactor.rb#39
Puma::Reactor::DefaultSleepFor = T.let(T.unsafe(nil), Integer)

# Generic class that is used by `Puma::Cluster` and `Puma::Single` to
# serve requests. This class spawns a new instance of `Puma::Server` via
# a call to `start_server`.
#
# source://puma//lib/puma/runner.rb#11
class Puma::Runner
  # @return [Runner] a new instance of Runner
  #
  # source://puma//lib/puma/runner.rb#12
  def initialize(cli, events); end

  # source://puma//lib/puma/runner.rb#164
  def app; end

  # source://puma//lib/puma/runner.rb#37
  def before_restart; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/runner.rb#21
  def daemon?; end

  # source://puma//lib/puma/runner.rb#45
  def debug(str); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/runner.rb#25
  def development?; end

  # source://puma//lib/puma/runner.rb#41
  def error(str); end

  # source://puma//lib/puma/runner.rb#147
  def load_and_bind; end

  # source://puma//lib/puma/runner.rb#33
  def log(str); end

  # source://puma//lib/puma/runner.rb#103
  def output_header(mode); end

  # source://puma//lib/puma/runner.rb#121
  def redirect_io; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/runner.rb#117
  def redirected_io?; end

  # source://puma//lib/puma/runner.rb#91
  def ruby_engine; end

  # source://puma//lib/puma/runner.rb#49
  def start_control; end

  # source://puma//lib/puma/runner.rb#168
  def start_server; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/runner.rb#29
  def test?; end
end

# For some HTTP status codes the client only expects headers.
#
# source://puma//lib/puma/const.rb#84
Puma::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# The HTTP Server itself. Serves out a single Rack app.
#
# This class is used by the `Puma::Single` and `Puma::Cluster` classes
# to generate one or more `Puma::Server` instances capable of handling requests.
# Each Puma process will contain one `Puma::Server` instance.
#
# The `Puma::Server` instance pulls requests from the socket, adds them to a
# `Puma::Reactor` where they get eventually passed to a `Puma::ThreadPool`.
#
# Each `Puma::Server` will have one reactor and one thread pool.
#
# source://puma//lib/puma/server.rb#32
class Puma::Server
  include ::Puma::Const
  extend ::Forwardable

  # Create a server for the rack app +app+.
  #
  # +events+ is an object which will be called when certain error events occur
  # to be handled. See Puma::Events for the list of current methods to implement.
  #
  # Server#run returns a thread that you can join on to wait for the server
  # to do its work.
  #
  # @return [Server] a new instance of Server
  #
  # source://puma//lib/puma/server.rb#56
  def initialize(app, events = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def add_ssl_listener(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def add_tcp_listener(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def add_unix_listener(*args, &block); end

  # Returns the value of attribute app.
  #
  # source://puma//lib/puma/server.rb#39
  def app; end

  # Sets the attribute app
  #
  # @param value the value to set the attribute app to.
  #
  # source://puma//lib/puma/server.rb#39
  def app=(_arg0); end

  # Returns the value of attribute auto_trim_time.
  #
  # source://puma//lib/puma/server.rb#44
  def auto_trim_time; end

  # Sets the attribute auto_trim_time
  #
  # @param value the value to set the attribute auto_trim_time to.
  #
  # source://puma//lib/puma/server.rb#44
  def auto_trim_time=(_arg0); end

  # source://puma//lib/puma/server.rb#155
  def backlog; end

  # source://puma//lib/puma/server.rb#1060
  def begin_restart; end

  # Returns the value of attribute binder.
  #
  # source://puma//lib/puma/server.rb#90
  def binder; end

  # Sets the attribute binder
  #
  # @param value the value to set the attribute binder to.
  #
  # source://puma//lib/puma/server.rb#90
  def binder=(_arg0); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/server.rb#127
  def closed_socket?(socket); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def connected_port(*args, &block); end

  # 6 == Socket::IPPROTO_TCP
  # 3 == TCP_CORK
  # 1/0 == turn on/off
  #
  # source://puma//lib/puma/server.rb#111
  def cork_socket(socket); end

  # source://puma//lib/puma/server.rb#621
  def default_server_port(env); end

  # Returns the value of attribute early_hints.
  #
  # source://puma//lib/puma/server.rb#90
  def early_hints; end

  # Sets the attribute early_hints
  #
  # @param value the value to set the attribute early_hints to.
  #
  # source://puma//lib/puma/server.rb#90
  def early_hints=(_arg0); end

  # Returns the value of attribute events.
  #
  # source://puma//lib/puma/server.rb#38
  def events; end

  # Returns the value of attribute first_data_timeout.
  #
  # source://puma//lib/puma/server.rb#46
  def first_data_timeout; end

  # Sets the attribute first_data_timeout
  #
  # @param value the value to set the attribute first_data_timeout to.
  #
  # source://puma//lib/puma/server.rb#46
  def first_data_timeout=(_arg0); end

  # Wait for all outstanding requests to finish.
  #
  # source://puma//lib/puma/server.rb#979
  def graceful_shutdown; end

  # source://puma//lib/puma/server.rb#1055
  def halt(sync = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#443
  def handle_check; end

  # Takes the request +req+, invokes the Rack application to construct
  # the response and writes it back to +req.io+.
  #
  # The second parameter +lines+ is a IO-like object unique to this thread.
  # This is normally an instance of Puma::IOBuffer.
  #
  # It'll return +false+ when the connection is closed, this doesn't mean
  # that the response wasn't successful.
  #
  # It'll return +:async+ if the connection remains open but will be handled
  # elsewhere, i.e. the connection has been hijacked by the Rack application.
  #
  # Finally, it'll return +true+ on keep-alive connections.
  #
  # source://puma//lib/puma/server.rb#642
  def handle_request(req, lines); end

  # source://puma//lib/puma/server.rb#368
  def handle_servers; end

  # source://puma//lib/puma/server.rb#217
  def handle_servers_lopez_mode; end

  # source://puma//lib/puma/server.rb#94
  def inherit_binder(bind); end

  # Returns the value of attribute leak_stack_on_error.
  #
  # source://puma//lib/puma/server.rb#90
  def leak_stack_on_error; end

  # Sets the attribute leak_stack_on_error
  #
  # @param value the value to set the attribute leak_stack_on_error to.
  #
  # source://puma//lib/puma/server.rb#90
  def leak_stack_on_error=(_arg0); end

  # A fallback rack response if +@app+ raises as exception.
  #
  # source://puma//lib/puma/server.rb#961
  def lowlevel_error(e, env); end

  # Returns the value of attribute max_threads.
  #
  # source://puma//lib/puma/server.rb#42
  def max_threads; end

  # Sets the attribute max_threads
  #
  # @param value the value to set the attribute max_threads to.
  #
  # source://puma//lib/puma/server.rb#42
  def max_threads=(_arg0); end

  # Returns the value of attribute min_threads.
  #
  # source://puma//lib/puma/server.rb#41
  def min_threads; end

  # Sets the attribute min_threads
  #
  # @param value the value to set the attribute min_threads to.
  #
  # source://puma//lib/puma/server.rb#41
  def min_threads=(_arg0); end

  # Given a Hash +env+ for the request read from +client+, add
  # and fixup keys to comply with Rack's env guidelines.
  #
  # source://puma//lib/puma/server.rb#568
  def normalize_env(env, client); end

  # Returns the value of attribute persistent_timeout.
  #
  # source://puma//lib/puma/server.rb#43
  def persistent_timeout; end

  # Sets the attribute persistent_timeout
  #
  # @param value the value to set the attribute persistent_timeout to.
  #
  # source://puma//lib/puma/server.rb#43
  def persistent_timeout=(_arg0); end

  # This number represents the number of requests that
  # the server is capable of taking right now.
  #
  # For example if the number is 5 then it means
  # there are 5 threads sitting idle ready to take
  # a request. If one request comes in, then the
  # value would be 4 until it finishes processing.
  #
  # source://puma//lib/puma/server.rb#171
  def pool_capacity; end

  # Given a connection on +client+, handle the incoming requests.
  #
  # This method support HTTP Keep-Alive so it may, depending on if the client
  # indicates that it supports keep alive, wait for another request before
  # returning.
  #
  # source://puma//lib/puma/server.rb#467
  def process_client(client, buffer); end

  # Given the request +env+ from +client+ and the partial body +body+
  # plus a potential Content-Length value +cl+, finish reading
  # the body and return it.
  #
  # If the body is larger than MAX_BODY, a Tempfile object is used
  # for the body, otherwise a StringIO is used.
  #
  # source://puma//lib/puma/server.rb#912
  def read_body(env, client, body, cl); end

  # Returns the value of attribute reaping_time.
  #
  # source://puma//lib/puma/server.rb#45
  def reaping_time; end

  # Sets the attribute reaping_time
  #
  # @param value the value to set the attribute reaping_time to.
  #
  # source://puma//lib/puma/server.rb#45
  def reaping_time=(_arg0); end

  # Runs the server.
  #
  # If +background+ is true (the default) then a thread is spun
  # up in the background to handle requests. Otherwise requests
  # are handled synchronously.
  #
  # source://puma//lib/puma/server.rb#282
  def run(background = T.unsafe(nil)); end

  # Lopez Mode == raw tcp apps
  #
  # source://puma//lib/puma/server.rb#177
  def run_lopez_mode(background = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#159
  def running; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/server.rb#1091
  def shutting_down?; end

  # Stops the acceptor thread and then causes the worker threads to finish
  # off the request queue before finally exiting.
  #
  # source://puma//lib/puma/server.rb#1050
  def stop(sync = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#98
  def tcp_mode!; end

  # Returns the value of attribute thread.
  #
  # source://puma//lib/puma/server.rb#37
  def thread; end

  # source://puma//lib/puma/server.rb#119
  def uncork_socket(socket); end

  private

  # source://puma//lib/puma/server.rb#1064
  def fast_write(io, str); end

  # source://puma//lib/puma/server.rb#900
  def fetch_status_code(status); end

  # source://puma//lib/puma/server.rb#1030
  def notify_safely(message); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/server.rb#1095
  def possible_header_injection?(header_value); end

  class << self
    # source://puma//lib/puma/server.rb#1087
    def current; end
  end
end

# source://puma//lib/puma/server.rb#1085
Puma::Server::ThreadLocalKey = T.let(T.unsafe(nil), Symbol)

# source://puma//lib/puma/server.rb#106
Puma::Server::UNPACK_TCP_STATE_FROM_TCP_INFO = T.let(T.unsafe(nil), String)

# This class is instantiated by the `Puma::Launcher` and used
# to boot and serve a Ruby application when no puma "workers" are needed
# i.e. only using "threaded" mode. For example `$ puma -t 1:5`
#
# At the core of this class is running an instance of `Puma::Server` which
# gets created via the `start_server` method from the `Puma::Runner` class
# that this inherits from.
#
# source://puma//lib/puma/single.rb#15
class Puma::Single < ::Puma::Runner
  # source://puma//lib/puma/single.rb#32
  def halt; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/single.rb#42
  def jruby_daemon?; end

  # source://puma//lib/puma/single.rb#46
  def jruby_daemon_start; end

  # source://puma//lib/puma/single.rb#24
  def restart; end

  # source://puma//lib/puma/single.rb#51
  def run; end

  # source://puma//lib/puma/single.rb#16
  def stats; end

  # source://puma//lib/puma/single.rb#28
  def stop; end

  # source://puma//lib/puma/single.rb#36
  def stop_blocked; end
end

# Internal Docs for A simple thread pool management object.
#
# Each Puma "worker" has a thread pool to process requests.
#
# First a connection to a client is made in `Puma::Server`. It is wrapped in a
# `Puma::Client` instance and then passed to the `Puma::Reactor` to ensure
# the whole request is buffered into memory. Once the request is ready, it is passed into
# a thread pool via the `Puma::ThreadPool#<<` operator where it is stored in a `@todo` array.
#
# Each thread in the pool has an internal loop where it pulls a request from the `@todo` array
# and proceses it.
#
# source://puma//lib/puma/thread_pool.rb#17
class Puma::ThreadPool
  # Maintain a minimum of +min+ and maximum of +max+ threads
  # in the pool.
  #
  # The block passed is the work that will be performed in each
  # thread.
  #
  # @return [ThreadPool] a new instance of ThreadPool
  #
  # source://puma//lib/puma/thread_pool.rb#32
  def initialize(min, max, *extra, &block); end

  # Add +work+ to the todo list for a Thread to pickup and process.
  #
  # source://puma//lib/puma/thread_pool.rb#154
  def <<(work); end

  # source://puma//lib/puma/thread_pool.rb#278
  def auto_reap!(timeout = T.unsafe(nil)); end

  # source://puma//lib/puma/thread_pool.rb#273
  def auto_trim!(timeout = T.unsafe(nil)); end

  # How many objects have yet to be processed by the pool?
  #
  # source://puma//lib/puma/thread_pool.rb#74
  def backlog; end

  # Returns the value of attribute clean_thread_locals.
  #
  # source://puma//lib/puma/thread_pool.rb#64
  def clean_thread_locals; end

  # Sets the attribute clean_thread_locals
  #
  # @param value the value to set the attribute clean_thread_locals to.
  #
  # source://puma//lib/puma/thread_pool.rb#64
  def clean_thread_locals=(_arg0); end

  # source://puma//lib/puma/thread_pool.rb#78
  def pool_capacity; end

  # If there are dead threads in the pool make them go away while decreasing
  # spawned counter so that new healthy threads could be created again.
  #
  # source://puma//lib/puma/thread_pool.rb#231
  def reap; end

  # Tell all threads in the pool to exit and wait for them to finish.
  #
  # source://puma//lib/puma/thread_pool.rb#285
  def shutdown(timeout = T.unsafe(nil)); end

  # Returns the value of attribute spawned.
  #
  # source://puma//lib/puma/thread_pool.rb#63
  def spawned; end

  # If too many threads are in the pool, tell one to finish go ahead
  # and exit. If +force+ is true, then a trim request is requested
  # even if all threads are being utilized.
  #
  # source://puma//lib/puma/thread_pool.rb#220
  def trim(force = T.unsafe(nil)); end

  # Returns the value of attribute trim_requested.
  #
  # source://puma//lib/puma/thread_pool.rb#63
  def trim_requested; end

  # This method is used by `Puma::Server` to let the server know when
  # the thread pool can pull more requests from the socket and
  # pass to the reactor.
  #
  # The general idea is that the thread pool can only work on a fixed
  # number of requests at the same time. If it is already processing that
  # number of requests then it is at capacity. If another Puma process has
  # spare capacity, then the request can be left on the socket so the other
  # worker can pick it up and process it.
  #
  # For example: if there are 5 threads, but only 4 working on
  # requests, this method will not wait and the `Puma::Server`
  # can pull a request right away.
  #
  # If there are 5 threads and all 5 of them are busy, then it will
  # pause here, and wait until the `not_full` condition variable is
  # signaled, usually this indicates that a request has been processed.
  #
  # It's important to note that even though the server might accept another
  # request, it might not be added to the `@todo` array right away.
  # For example if a slow client has only sent a header, but not a body
  # then the `@todo` array would stay the same size as the reactor works
  # to try to buffer the request. In that scenario the next call to this
  # method would not block and another request would be added into the reactor
  # by the server. This would continue until a fully bufferend request
  # makes it through the reactor and can then be processed by the thread pool.
  #
  # Returns the current number of busy threads, or +nil+ if shutting down.
  #
  # source://puma//lib/puma/thread_pool.rb#199
  def wait_until_not_full; end

  # Returns the value of attribute waiting.
  #
  # source://puma//lib/puma/thread_pool.rb#63
  def waiting; end

  private

  #
  # Must be called with @mutex held!
  #
  # source://puma//lib/puma/thread_pool.rb#86
  def spawn_thread; end

  class << self
    # source://puma//lib/puma/thread_pool.rb#66
    def clean_thread_locals; end
  end
end

# source://puma//lib/puma/thread_pool.rb#246
class Puma::ThreadPool::Automaton
  # @return [Automaton] a new instance of Automaton
  #
  # source://puma//lib/puma/thread_pool.rb#247
  def initialize(pool, timeout, thread_name, message); end

  # source://puma//lib/puma/thread_pool.rb#255
  def start!; end

  # source://puma//lib/puma/thread_pool.rb#267
  def stop; end
end

# source://puma//lib/puma/thread_pool.rb#18
class Puma::ThreadPool::ForceShutdown < ::RuntimeError; end

# How long, after raising the ForceShutdown of a thread during
# forced shutdown mode, to wait for the thread to try and finish
# up its work before leaving the thread to die on the vine.
#
# source://puma//lib/puma/thread_pool.rb#24
Puma::ThreadPool::SHUTDOWN_GRACE_TIME = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/plugin.rb#4
class Puma::UnknownPlugin < ::RuntimeError; end

# source://puma//lib/puma/const.rb#5
class Puma::UnsupportedOption < ::RuntimeError; end

# source://puma//lib/puma/util.rb#6
module Puma::Util
  private

  # Stolen from Mongrel, with some small modifications:
  # Parses a query string by breaking it up at the '&'
  # and ';' characters.  You can also use this to parse
  # cookies by changing the characters used in the second
  # parameter (which defaults to '&;').
  #
  # source://puma//lib/puma/util.rb#33
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  # source://puma//lib/puma/util.rb#9
  def pipe; end

  # source://puma//lib/puma/util.rb#16
  def unescape(s, encoding = T.unsafe(nil)); end

  class << self
    # Stolen from Mongrel, with some small modifications:
    # Parses a query string by breaking it up at the '&'
    # and ';' characters.  You can also use this to parse
    # cookies by changing the characters used in the second
    # parameter (which defaults to '&;').
    #
    # source://puma//lib/puma/util.rb#33
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end

    # source://puma//lib/puma/util.rb#9
    def pipe; end

    # source://puma//lib/puma/util.rb#16
    def unescape(s, encoding = T.unsafe(nil)); end
  end
end

# source://puma//lib/puma/util.rb#26
Puma::Util::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# A case-insensitive Hash that preserves the original case of a
# header when set.
#
# source://puma//lib/puma/util.rb#58
class Puma::Util::HeaderHash < ::Hash
  # @return [HeaderHash] a new instance of HeaderHash
  #
  # source://puma//lib/puma/util.rb#63
  def initialize(hash = T.unsafe(nil)); end

  # source://puma//lib/puma/util.rb#81
  def [](k); end

  # source://puma//lib/puma/util.rb#85
  def []=(k, v); end

  # source://puma//lib/puma/util.rb#92
  def delete(k); end

  # source://puma//lib/puma/util.rb#69
  def each; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/util.rb#99
  def has_key?(k); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/util.rb#99
  def include?(k); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/util.rb#99
  def key?(k); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/util.rb#99
  def member?(k); end

  # source://puma//lib/puma/util.rb#112
  def merge(other); end

  # source://puma//lib/puma/util.rb#107
  def merge!(other); end

  # source://puma//lib/puma/util.rb#117
  def replace(other); end

  # source://puma//lib/puma/util.rb#75
  def to_hash; end

  class << self
    # source://puma//lib/puma/util.rb#59
    def new(hash = T.unsafe(nil)); end
  end
end
