# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `listen` gem.
# Please instead update this file by running `bin/tapioca gem listen`.

# This class just aggregates configuration object to avoid Listener specs
# from exploding with huge test setup blocks
#
# source://listen//lib/listen/logger.rb#1
module Listen
  class << self
    # source://listen//lib/listen/logger.rb#2
    def logger; end

    # source://listen//lib/listen/logger.rb#6
    def logger=(logger); end

    # source://listen//lib/listen/logger.rb#10
    def setup_default_logger_if_unset; end

    # This is used by the `listen` binary to handle Ctrl-C
    #
    # source://listen//lib/listen.rb#48
    def stop; end

    # Listens to file system modifications on a either single directory or
    # multiple directories.
    #
    # @return [Listen::Listener] the listener
    # @yield [modified, added, removed] the changed files
    # @yieldparam modified [Array<String>] the list of modified files
    # @yieldparam added [Array<String>] the list of added files
    # @yieldparam removed [Array<String>] the list of removed files
    #
    # source://listen//lib/listen.rb#39
    def to(*args, &block); end
  end
end

# source://listen//lib/listen/adapter/base.rb#6
module Listen::Adapter
  class << self
    # source://listen//lib/listen/adapter.rb#15
    def select(options = T.unsafe(nil)); end

    private

    # source://listen//lib/listen/adapter.rb#40
    def _log(type, message); end

    # source://listen//lib/listen/adapter.rb#31
    def _usable_adapter_class; end

    # source://listen//lib/listen/adapter.rb#35
    def _warn_polling_fallback(options); end
  end
end

# source://listen//lib/listen/adapter/bsd.rb#7
class Listen::Adapter::BSD < ::Listen::Adapter::Base
  private

  # source://listen//lib/listen/adapter/bsd.rb#71
  def _change(event_flags); end

  # source://listen//lib/listen/adapter/bsd.rb#41
  def _configure(directory, &callback); end

  # source://listen//lib/listen/adapter/bsd.rb#81
  def _event_path(event); end

  # Quick rubocop workaround
  #
  # source://listen//lib/listen/adapter/bsd.rb#101
  def _find(*paths, &block); end

  # source://listen//lib/listen/adapter/bsd.rb#53
  def _process_event(dir, event); end

  # source://listen//lib/listen/adapter/bsd.rb#49
  def _run; end

  # source://listen//lib/listen/adapter/bsd.rb#94
  def _watch_file(path, queue); end

  # source://listen//lib/listen/adapter/bsd.rb#85
  def _watch_for_new_file(event); end

  class << self
    # @return [Boolean]
    #
    # source://listen//lib/listen/adapter/bsd.rb#29
    def usable?; end
  end
end

# source://listen//lib/listen/adapter/bsd.rb#21
Listen::Adapter::BSD::BUNDLER_DECLARE_GEM = T.let(T.unsafe(nil), String)

# source://listen//lib/listen/adapter/bsd.rb#10
Listen::Adapter::BSD::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://listen//lib/listen/adapter/bsd.rb#8
Listen::Adapter::BSD::OS_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://listen//lib/listen/adapter/base.rb#7
class Listen::Adapter::Base
  # @return [Base] a new instance of Base
  #
  # source://listen//lib/listen/adapter/base.rb#15
  def initialize(config); end

  # Returns the value of attribute config.
  #
  # source://listen//lib/listen/adapter/base.rb#13
  def config; end

  # TODO: it's a separate method as a temporary workaround for tests
  #
  # source://listen//lib/listen/adapter/base.rb#31
  def configure; end

  # Returns the value of attribute options.
  #
  # source://listen//lib/listen/adapter/base.rb#8
  def options; end

  # source://listen//lib/listen/adapter/base.rb#62
  def start; end

  # @return [Boolean]
  #
  # source://listen//lib/listen/adapter/base.rb#58
  def started?; end

  # source://listen//lib/listen/adapter/base.rb#88
  def stop; end

  private

  # source://listen//lib/listen/adapter/base.rb#117
  def _log(*args, &block); end

  # source://listen//lib/listen/adapter/base.rb#121
  def _log_exception(msg, caller_stack); end

  # TODO: allow backend adapters to pass specific invalidation objects
  # e.g. Darwin -> DirRescan, INotify -> MoveScan, etc.
  #
  # source://listen//lib/listen/adapter/base.rb#113
  def _queue_change(type, dir, rel_path, options); end

  # source://listen//lib/listen/adapter/base.rb#98
  def _stop; end

  # source://listen//lib/listen/adapter/base.rb#101
  def _timed(title); end

  class << self
    # @return [Boolean]
    #
    # source://listen//lib/listen/adapter/base.rb#92
    def usable?; end

    private

    # source://listen//lib/listen/adapter/base.rb#135
    def _log(*args, &block); end
  end
end

# TODO: only used by tests
#
# source://listen//lib/listen/adapter/base.rb#11
Listen::Adapter::Base::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://listen//lib/listen/adapter/config.rb#5
class Listen::Adapter::Config
  # @return [Config] a new instance of Config
  #
  # source://listen//lib/listen/adapter/config.rb#11
  def initialize(directories, queue, silencer, adapter_options); end

  # Returns the value of attribute adapter_options.
  #
  # source://listen//lib/listen/adapter/config.rb#9
  def adapter_options; end

  # Returns the value of attribute directories.
  #
  # source://listen//lib/listen/adapter/config.rb#6
  def directories; end

  # Returns the value of attribute queue.
  #
  # source://listen//lib/listen/adapter/config.rb#8
  def queue; end

  # Returns the value of attribute silencer.
  #
  # source://listen//lib/listen/adapter/config.rb#7
  def silencer; end
end

# Adapter implementation for Mac OS X `FSEvents`.
#
# source://listen//lib/listen/adapter/darwin.rb#8
class Listen::Adapter::Darwin < ::Listen::Adapter::Base
  private

  # NOTE: each directory gets a DIFFERENT callback!
  #
  # source://listen//lib/listen/adapter/darwin.rb#39
  def _configure(dir, &callback); end

  # source://listen//lib/listen/adapter/darwin.rb#58
  def _process_event(dir, event); end

  # source://listen//lib/listen/adapter/darwin.rb#49
  def _run; end

  # source://listen//lib/listen/adapter/darwin.rb#69
  def _run_worker(worker); end

  # source://listen//lib/listen/adapter/darwin.rb#77
  def _run_workers_in_background(workers); end

  # source://listen//lib/listen/adapter/darwin.rb#85
  def _to_array(queue); end

  class << self
    # @return [Boolean]
    #
    # source://listen//lib/listen/adapter/darwin.rb#24
    def usable?; end
  end
end

# The default delay between checking for changes.
#
# source://listen//lib/listen/adapter/darwin.rb#12
Listen::Adapter::Darwin::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://listen//lib/listen/adapter/darwin.rb#14
Listen::Adapter::Darwin::INCOMPATIBLE_GEM_VERSION = T.let(T.unsafe(nil), String)

# source://listen//lib/listen/adapter/darwin.rb#9
Listen::Adapter::Darwin::OS_REGEXP = T.let(T.unsafe(nil), Regexp)

# @see https://github.com/nex3/rb-inotify
#
# source://listen//lib/listen/adapter/linux.rb#4
class Listen::Adapter::Linux < ::Listen::Adapter::Base
  private

  # source://listen//lib/listen/adapter/linux.rb#86
  def _change(event_flags); end

  # source://listen//lib/listen/adapter/linux.rb#29
  def _configure(directory, &callback); end

  # @return [Boolean]
  #
  # source://listen//lib/listen/adapter/linux.rb#97
  def _dir_event?(event); end

  # source://listen//lib/listen/adapter/linux.rb#43
  def _process_event(dir, event); end

  # source://listen//lib/listen/adapter/linux.rb#37
  def _run; end

  # @return [Boolean]
  #
  # source://listen//lib/listen/adapter/linux.rb#76
  def _skip_event?(event); end

  # source://listen//lib/listen/adapter/linux.rb#101
  def _stop; end
end

# source://listen//lib/listen/adapter/linux.rb#7
Listen::Adapter::Linux::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://listen//lib/listen/adapter/linux.rb#24
Listen::Adapter::Linux::INOTIFY_LIMIT_MESSAGE = T.let(T.unsafe(nil), String)

# source://listen//lib/listen/adapter/linux.rb#5
Listen::Adapter::Linux::OS_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://listen//lib/listen/adapter/linux.rb#21
Listen::Adapter::Linux::WIKI_URL = T.let(T.unsafe(nil), String)

# source://listen//lib/listen/adapter.rb#10
Listen::Adapter::OPTIMIZED_ADAPTERS = T.let(T.unsafe(nil), Array)

# source://listen//lib/listen/adapter.rb#11
Listen::Adapter::POLLING_FALLBACK_MESSAGE = T.let(T.unsafe(nil), String)

# Polling Adapter that works cross-platform and
# has no dependencies. This is the adapter that
# uses the most CPU processing power and has higher
# file IO than the other implementations.
#
# source://listen//lib/listen/adapter/polling.rb#8
class Listen::Adapter::Polling < ::Listen::Adapter::Base
  private

  # source://listen//lib/listen/adapter/polling.rb#15
  def _configure(_, &callback); end

  # source://listen//lib/listen/adapter/polling.rb#32
  def _process_event(dir, _); end

  # source://listen//lib/listen/adapter/polling.rb#20
  def _run; end
end

# source://listen//lib/listen/adapter/polling.rb#11
Listen::Adapter::Polling::DEFAULTS = T.let(T.unsafe(nil), Hash)

# match every OS
#
# source://listen//lib/listen/adapter/polling.rb#9
Listen::Adapter::Polling::OS_REGEXP = T.let(T.unsafe(nil), Regexp)

# Adapter implementation for Windows `wdm`.
#
# source://listen//lib/listen/adapter/windows.rb#5
class Listen::Adapter::Windows < ::Listen::Adapter::Base
  private

  # source://listen//lib/listen/adapter/windows.rb#88
  def _change(type); end

  # source://listen//lib/listen/adapter/windows.rb#27
  def _configure(dir); end

  # source://listen//lib/listen/adapter/windows.rb#49
  def _process_event(dir, event); end

  # source://listen//lib/listen/adapter/windows.rb#45
  def _run; end

  class << self
    # @return [Boolean]
    #
    # source://listen//lib/listen/adapter/windows.rb#13
    def usable?; end
  end
end

# source://listen//lib/listen/adapter/windows.rb#8
Listen::Adapter::Windows::BUNDLER_DECLARE_GEM = T.let(T.unsafe(nil), String)

# source://listen//lib/listen/adapter/windows.rb#6
Listen::Adapter::Windows::OS_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://listen//lib/listen/backend.rb#10
class Listen::Backend
  extend ::Forwardable

  # @return [Backend] a new instance of Backend
  #
  # source://listen//lib/listen/backend.rb#13
  def initialize(directories, queue, silencer, config); end

  # Returns the value of attribute min_delay_between_events.
  #
  # source://listen//lib/listen/backend.rb#32
  def min_delay_between_events; end

  # source://forwardable/1.3.1/forwardable.rb#226
  def start(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def stop(*args, &block); end

  private

  # Returns the value of attribute adapter.
  #
  # source://listen//lib/listen/backend.rb#36
  def adapter; end
end

# TODO: rename to Snapshot
#
# source://listen//lib/listen/change.rb#6
class Listen::Change
  # @return [Change] a new instance of Change
  #
  # source://listen//lib/listen/change.rb#25
  def initialize(config, record); end

  # Invalidate some part of the snapshot/record (dir, file, subtree, etc.)
  #
  # source://listen//lib/listen/change.rb#31
  def invalidate(type, rel_path, options); end

  # Returns the value of attribute record.
  #
  # source://listen//lib/listen/change.rb#23
  def record; end

  private

  # Returns the value of attribute config.
  #
  # source://listen//lib/listen/change.rb#74
  def config; end
end

# TODO: test this class for coverage
#
# source://listen//lib/listen/change.rb#8
class Listen::Change::Config
  # @return [Config] a new instance of Config
  #
  # source://listen//lib/listen/change.rb#9
  def initialize(queue, silencer); end

  # source://listen//lib/listen/change.rb#18
  def queue(*args); end

  # @return [Boolean]
  #
  # source://listen//lib/listen/change.rb#14
  def silenced?(path, type); end
end

# TODO: refactor (turn it into a normal object, cache the stat, etc)
#
# source://listen//lib/listen/directory.rb#5
class Listen::Directory
  class << self
    # source://listen//lib/listen/directory.rb#56
    def _async_changes(snapshot, path, previous, options); end

    # source://listen//lib/listen/directory.rb#66
    def _change(snapshot, type, path, options); end

    # @raise [Errno::ENOTDIR]
    #
    # source://listen//lib/listen/directory.rb#76
    def _children(path); end

    # source://listen//lib/listen/directory.rb#6
    def scan(snapshot, rel_path, options); end
  end
end

# source://listen//lib/listen/event/processor.rb#2
module Listen::Event; end

# source://listen//lib/listen/event/config.rb#3
class Listen::Event::Config
  # @return [Config] a new instance of Config
  #
  # source://listen//lib/listen/event/config.rb#4
  def initialize(listener, event_queue, queue_optimizer, wait_for_delay, &block); end

  # source://listen//lib/listen/event/config.rb#22
  def call(*args); end

  # @return [Boolean]
  #
  # source://listen//lib/listen/event/config.rb#32
  def callable?; end

  # Returns the value of attribute event_queue.
  #
  # source://listen//lib/listen/event/config.rb#30
  def event_queue; end

  # Returns the value of attribute min_delay_between_events.
  #
  # source://listen//lib/listen/event/config.rb#40
  def min_delay_between_events; end

  # source://listen//lib/listen/event/config.rb#36
  def optimize_changes(changes); end

  # @return [Boolean]
  #
  # source://listen//lib/listen/event/config.rb#46
  def paused?; end

  # source://listen//lib/listen/event/config.rb#18
  def sleep(*args); end

  # @return [Boolean]
  #
  # source://listen//lib/listen/event/config.rb#42
  def stopped?; end

  # source://listen//lib/listen/event/config.rb#26
  def timestamp; end

  private

  # Returns the value of attribute listener.
  #
  # source://listen//lib/listen/event/config.rb#52
  def listener; end
end

# source://listen//lib/listen/event/loop.rb#8
class Listen::Event::Loop
  # @return [Loop] a new instance of Loop
  #
  # source://listen//lib/listen/event/loop.rb#14
  def initialize(config); end

  # source://listen//lib/listen/event/loop.rb#55
  def pause; end

  # @return [Boolean]
  #
  # source://listen//lib/listen/event/loop.rb#28
  def paused?; end

  # @return [Boolean]
  #
  # source://listen//lib/listen/event/loop.rb#32
  def processing?; end

  # source://listen//lib/listen/event/loop.rb#49
  def resume; end

  # source://listen//lib/listen/event/loop.rb#38
  def setup; end

  # @return [Boolean]
  #
  # source://listen//lib/listen/event/loop.rb#69
  def stopped?; end

  # source://listen//lib/listen/event/loop.rb#60
  def teardown; end

  # source://listen//lib/listen/event/loop.rb#21
  def wakeup_on_event; end

  private

  # source://listen//lib/listen/event/loop.rb#100
  def _nice_error(ex); end

  # source://listen//lib/listen/event/loop.rb#89
  def _sleep(*args); end

  # source://listen//lib/listen/event/loop.rb#80
  def _wait_for_changes(ready_queue, config); end

  # source://listen//lib/listen/event/loop.rb#93
  def _wait_until_resumed(ready_queue); end

  # source://listen//lib/listen/event/loop.rb#111
  def _wakeup(reason); end

  # Returns the value of attribute config.
  #
  # source://listen//lib/listen/event/loop.rb#75
  def config; end

  # Returns the value of attribute state.
  #
  # source://listen//lib/listen/event/loop.rb#78
  def state; end

  # Sets the attribute state
  #
  # @param value the value to set the attribute state to.
  #
  # source://listen//lib/listen/event/loop.rb#78
  def state=(_arg0); end

  # Returns the value of attribute wait_thread.
  #
  # source://listen//lib/listen/event/loop.rb#76
  def wait_thread; end
end

# source://listen//lib/listen/event/loop.rb#9
class Listen::Event::Loop::Error < ::RuntimeError; end

# source://listen//lib/listen/event/loop.rb#10
class Listen::Event::Loop::Error::NotStarted < ::Listen::Event::Loop::Error; end

# source://listen//lib/listen/event/processor.rb#3
class Listen::Event::Processor
  # @return [Processor] a new instance of Processor
  #
  # source://listen//lib/listen/event/processor.rb#4
  def initialize(config, reasons); end

  # TODO: implement this properly instead of checking the state at arbitrary
  # points in time
  #
  # source://listen//lib/listen/event/processor.rb#12
  def loop_for(latency); end

  private

  # @raise [Stopped]
  #
  # source://listen//lib/listen/event/processor.rb#50
  def _check_stopped; end

  # source://listen//lib/listen/event/processor.rb#78
  def _deadline; end

  # source://listen//lib/listen/event/processor.rb#88
  def _flush_wakeup_reasons; end

  # for easier testing without sleep loop
  #
  # source://listen//lib/listen/event/processor.rb#101
  def _process_changes; end

  # source://listen//lib/listen/event/processor.rb#70
  def _remember_time_of_first_unprocessed_event; end

  # source://listen//lib/listen/event/processor.rb#74
  def _reset_no_unprocessed_events; end

  # source://listen//lib/listen/event/processor.rb#57
  def _sleep(_local_reason, *args); end

  # source://listen//lib/listen/event/processor.rb#96
  def _timestamp; end

  # source://listen//lib/listen/event/processor.rb#82
  def _wait_until_events; end

  # source://listen//lib/listen/event/processor.rb#30
  def _wait_until_events_calm_down; end

  # source://listen//lib/listen/event/processor.rb#45
  def _wait_until_no_longer_paused; end

  # Returns the value of attribute config.
  #
  # source://listen//lib/listen/event/processor.rb#119
  def config; end
end

# source://listen//lib/listen/event/processor.rb#27
class Listen::Event::Processor::Stopped < ::RuntimeError; end

# source://listen//lib/listen/event/queue.rb#7
class Listen::Event::Queue
  extend ::Forwardable

  # @return [Queue] a new instance of Queue
  #
  # source://listen//lib/listen/event/queue.rb#20
  def initialize(config, &block); end

  # source://listen//lib/listen/event/queue.rb#26
  def <<(args); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def empty?(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def pop(*args, &block); end

  private

  # source://listen//lib/listen/event/queue.rb#47
  def _safe_relative_from_cwd(dir); end

  # Returns the value of attribute block.
  #
  # source://listen//lib/listen/event/queue.rb#44
  def block; end

  # Returns the value of attribute config.
  #
  # source://listen//lib/listen/event/queue.rb#45
  def config; end

  # Returns the value of attribute event_queue.
  #
  # source://listen//lib/listen/event/queue.rb#43
  def event_queue; end
end

# source://listen//lib/listen/event/queue.rb#10
class Listen::Event::Queue::Config
  # @return [Config] a new instance of Config
  #
  # source://listen//lib/listen/event/queue.rb#11
  def initialize(relative); end

  # @return [Boolean]
  #
  # source://listen//lib/listen/event/queue.rb#15
  def relative?; end
end

# source://listen//lib/listen/fsm.rb#3
module Listen::FSM
  mixes_in_class_methods ::Listen::FSM::ClassMethods

  # Be kind and call super if you must redefine initialize
  #
  # source://listen//lib/listen/fsm.rb#47
  def initialize; end

  # Obtain the current state of the FSM
  #
  # source://listen//lib/listen/fsm.rb#52
  def state; end

  # source://listen//lib/listen/fsm.rb#54
  def transition(state_name); end

  # Immediate state transition with no checks, or callbacks. "Dangerous!"
  #
  # source://listen//lib/listen/fsm.rb#61
  def transition!(state_name); end

  protected

  # source://listen//lib/listen/fsm.rb#102
  def current_state; end

  # source://listen//lib/listen/fsm.rb#106
  def current_state_name; end

  # source://listen//lib/listen/fsm.rb#98
  def default_state; end

  # source://listen//lib/listen/fsm.rb#94
  def states; end

  # source://listen//lib/listen/fsm.rb#89
  def transition_with_callbacks!(state_name); end

  # source://listen//lib/listen/fsm.rb#67
  def validate_and_sanitize_new_state(state_name); end

  class << self
    # Included hook to extend class methods
    #
    # source://listen//lib/listen/fsm.rb#7
    def included(klass); end
  end
end

# source://listen//lib/listen/fsm.rb#11
module Listen::FSM::ClassMethods
  # Obtain or set the default state
  # Passing a state name sets the default state
  #
  # source://listen//lib/listen/fsm.rb#14
  def default_state(new_default = T.unsafe(nil)); end

  # Declare an FSM state and optionally provide a callback block to fire
  # Options:
  # * to: a state or array of states this state can transition to
  #
  # source://listen//lib/listen/fsm.rb#30
  def state(*args, &block); end

  # Obtain the valid states for this FSM
  #
  # source://listen//lib/listen/fsm.rb#23
  def states; end
end

# Default state name unless one is explicitly set
#
# source://listen//lib/listen/fsm.rb#4
Listen::FSM::DEFAULT_STATE = T.let(T.unsafe(nil), Symbol)

# source://listen//lib/listen/fsm.rb#110
class Listen::FSM::State
  # @return [State] a new instance of State
  #
  # source://listen//lib/listen/fsm.rb#113
  def initialize(name, transitions = T.unsafe(nil), &block); end

  # source://listen//lib/listen/fsm.rb#120
  def call(obj); end

  # Returns the value of attribute name.
  #
  # source://listen//lib/listen/fsm.rb#111
  def name; end

  # Returns the value of attribute transitions.
  #
  # source://listen//lib/listen/fsm.rb#111
  def transitions; end

  # @return [Boolean]
  #
  # source://listen//lib/listen/fsm.rb#124
  def valid_transition?(new_state); end
end

# source://listen//lib/listen/file.rb#4
class Listen::File
  class << self
    # source://listen//lib/listen/file.rb#5
    def change(record, rel_path); end

    # @return [Boolean]
    #
    # source://listen//lib/listen/file.rb#71
    def inaccurate_mac_time?(stat); end
  end
end

# @private api
#
# source://listen//lib/listen/internals/thread_pool.rb#3
module Listen::Internals; end

# source://listen//lib/listen/internals/thread_pool.rb#4
module Listen::Internals::ThreadPool
  class << self
    # source://listen//lib/listen/internals/thread_pool.rb#5
    def add(&block); end

    # source://listen//lib/listen/internals/thread_pool.rb#11
    def stop; end
  end
end

# source://listen//lib/listen/listener/config.rb#2
class Listen::Listener
  include ::Listen::FSM
  extend ::Listen::FSM::ClassMethods

  # Initializes the directories listener.
  #
  # @param directory [String] the directories to listen to
  # @param options [Hash] the listen options (see Listen::Listener::Options)
  # @return [Listener] a new instance of Listener
  # @yield [modified, added, removed] the changed files
  # @yieldparam modified [Array<String>] the list of modified files
  # @yieldparam added [Array<String>] the list of added files
  # @yieldparam removed [Array<String>] the list of removed files
  #
  # source://listen//lib/listen/listener.rb#35
  def initialize(*dirs, &block); end

  # source://listen//lib/listen/listener.rb#116
  def ignore(regexps); end

  # source://listen//lib/listen/listener.rb#120
  def ignore!(regexps); end

  # source://listen//lib/listen/listener.rb#124
  def only(regexps); end

  # Stops invoking callbacks (messages pile up)
  #
  # source://listen//lib/listen/listener.rb#103
  def pause; end

  # @return [Boolean]
  #
  # source://listen//lib/listen/listener.rb#112
  def paused?; end

  # processing means callbacks are called
  #
  # @return [Boolean]
  #
  # source://listen//lib/listen/listener.rb#108
  def processing?; end

  # Starts processing events and starts adapters
  # or resumes invoking callbacks if paused
  #
  # source://listen//lib/listen/listener.rb#90
  def start; end

  # Stops both listening for events and processing them
  #
  # source://listen//lib/listen/listener.rb#98
  def stop; end

  private

  # Returns the value of attribute backend.
  #
  # source://listen//lib/listen/listener.rb#131
  def backend; end

  # Returns the value of attribute processor.
  #
  # source://listen//lib/listen/listener.rb#130
  def processor; end
end

# source://listen//lib/listen/listener/config.rb#3
class Listen::Listener::Config
  # @return [Config] a new instance of Config
  #
  # source://listen//lib/listen/listener/config.rb#15
  def initialize(opts); end

  # source://listen//lib/listen/listener/config.rb#30
  def adapter_instance_options(klass); end

  # source://listen//lib/listen/listener/config.rb#35
  def adapter_select_options; end

  # Returns the value of attribute min_delay_between_events.
  #
  # source://listen//lib/listen/listener/config.rb#26
  def min_delay_between_events; end

  # @return [Boolean]
  #
  # source://listen//lib/listen/listener/config.rb#22
  def relative?; end

  # Returns the value of attribute silencer_rules.
  #
  # source://listen//lib/listen/listener/config.rb#28
  def silencer_rules; end
end

# source://listen//lib/listen/listener/config.rb#4
Listen::Listener::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://listen//lib/listen/logger.rb#25
class Listen::Logger
  class << self
    # source://listen//lib/listen/logger.rb#27
    def debug(*args, &block); end

    # source://listen//lib/listen/logger.rb#27
    def error(*args, &block); end

    # source://listen//lib/listen/logger.rb#27
    def fatal(*args, &block); end

    # source://listen//lib/listen/logger.rb#27
    def info(*args, &block); end

    # source://listen//lib/listen/logger.rb#27
    def warn(*args, &block); end
  end
end

# source://listen//lib/listen/options.rb#2
class Listen::Options
  # @return [Options] a new instance of Options
  #
  # source://listen//lib/listen/options.rb#3
  def initialize(opts, defaults); end

  # source://listen//lib/listen/options.rb#17
  def method_missing(name, *_); end
end

# source://listen//lib/listen/queue_optimizer.rb#2
class Listen::QueueOptimizer
  # @return [QueueOptimizer] a new instance of QueueOptimizer
  #
  # source://listen//lib/listen/queue_optimizer.rb#30
  def initialize(config); end

  # source://listen//lib/listen/queue_optimizer.rb#22
  def smoosh_changes(changes); end

  private

  # source://listen//lib/listen/queue_optimizer.rb#67
  def _calculate_add_remove_difference(actions, path, default_if_exists); end

  # source://listen//lib/listen/queue_optimizer.rb#107
  def _detect_possible_editor_save(changes); end

  # source://listen//lib/listen/queue_optimizer.rb#59
  def _logical_action_for(path, actions); end

  # remove extraneous rb-inotify events, keeping them only if it's a possible
  # editor rename() call (e.g. Kate and Sublime)
  #
  # source://listen//lib/listen/queue_optimizer.rb#89
  def _reinterpret_related_changes(cookies); end

  # groups changes into the expected structure expected by
  # clients
  #
  # source://listen//lib/listen/queue_optimizer.rb#40
  def _squash_changes(changes); end

  # Returns the value of attribute config.
  #
  # source://listen//lib/listen/queue_optimizer.rb#36
  def config; end
end

# source://listen//lib/listen/queue_optimizer.rb#3
class Listen::QueueOptimizer::Config
  # @return [Config] a new instance of Config
  #
  # source://listen//lib/listen/queue_optimizer.rb#4
  def initialize(adapter_class, silencer); end

  # source://listen//lib/listen/queue_optimizer.rb#17
  def debug(*args, &block); end

  # @return [Boolean]
  #
  # source://listen//lib/listen/queue_optimizer.rb#9
  def exist?(path); end

  # @return [Boolean]
  #
  # source://listen//lib/listen/queue_optimizer.rb#13
  def silenced?(path, type); end
end

# @private api
#
# source://listen//lib/listen/record/entry.rb#3
class Listen::Record
  # @return [Record] a new instance of Record
  #
  # source://listen//lib/listen/record.rb#11
  def initialize(directory); end

  # source://listen//lib/listen/record.rb#16
  def add_dir(rel_path); end

  # source://listen//lib/listen/record.rb#60
  def build; end

  # source://listen//lib/listen/record.rb#43
  def dir_entries(rel_path); end

  # source://listen//lib/listen/record.rb#31
  def file_data(rel_path); end

  # TODO: one Record object per watched directory?
  # TODO: deprecate
  #
  # source://listen//lib/listen/record.rb#10
  def root; end

  # source://listen//lib/listen/record.rb#26
  def unset_path(rel_path); end

  # source://listen//lib/listen/record.rb#21
  def update_file(rel_path, data); end

  private

  # source://listen//lib/listen/record.rb#73
  def _auto_hash; end

  # source://listen//lib/listen/record.rb#100
  def _fast_build_dir(remaining, symlink_detector); end

  # source://listen//lib/listen/record.rb#112
  def _fast_try_file(entry); end

  # source://listen//lib/listen/record.rb#88
  def _fast_unset_path(dirname, basename); end

  # source://listen//lib/listen/record.rb#79
  def _fast_update_file(dirname, basename, data); end

  # Returns the value of attribute tree.
  #
  # source://listen//lib/listen/record.rb#77
  def tree; end
end

# Represents a directory entry (dir or file)
#
# source://listen//lib/listen/record/entry.rb#5
class Listen::Record::Entry
  # file: "/home/me/watched_dir", "app/models", "foo.rb"
  # dir, "/home/me/watched_dir", "."
  #
  # @return [Entry] a new instance of Entry
  #
  # source://listen//lib/listen/record/entry.rb#8
  def initialize(root, relative, name = T.unsafe(nil)); end

  # source://listen//lib/listen/record/entry.rb#16
  def children; end

  # source://listen//lib/listen/record/entry.rb#23
  def meta; end

  # Returns the value of attribute name.
  #
  # source://listen//lib/listen/record/entry.rb#14
  def name; end

  # source://listen//lib/listen/record/entry.rb#41
  def real_path; end

  # record hash is e.g.
  # if @record["/home/me/watched_dir"]["project/app/models"]["foo.rb"]
  # if @record["/home/me/watched_dir"]["project/app"]["models"]
  # record_dir_key is "project/app/models"
  #
  # source://listen//lib/listen/record/entry.rb#32
  def record_dir_key; end

  # Returns the value of attribute relative.
  #
  # source://listen//lib/listen/record/entry.rb#14
  def relative; end

  # Returns the value of attribute root.
  #
  # source://listen//lib/listen/record/entry.rb#14
  def root; end

  # source://listen//lib/listen/record/entry.rb#36
  def sys_path; end

  private

  # @raise [Errno::ENOTDIR]
  #
  # source://listen//lib/listen/record/entry.rb#52
  def _entries(dir); end

  # source://listen//lib/listen/record/entry.rb#47
  def _join; end
end

# source://listen//lib/listen/record/symlink_detector.rb#6
class Listen::Record::SymlinkDetector
  # @return [SymlinkDetector] a new instance of SymlinkDetector
  #
  # source://listen//lib/listen/record/symlink_detector.rb#22
  def initialize; end

  # source://listen//lib/listen/record/symlink_detector.rb#26
  def verify_unwatched!(entry); end

  private

  # source://listen//lib/listen/record/symlink_detector.rb#33
  def _fail(symlinked, real_path); end
end

# source://listen//lib/listen/record/symlink_detector.rb#19
class Listen::Record::SymlinkDetector::Error < ::RuntimeError; end

# source://listen//lib/listen/record/symlink_detector.rb#9
Listen::Record::SymlinkDetector::SYMLINK_LOOP_ERROR = T.let(T.unsafe(nil), String)

# source://listen//lib/listen/record/symlink_detector.rb#7
Listen::Record::SymlinkDetector::WIKI = T.let(T.unsafe(nil), String)

# source://listen//lib/listen/silencer.rb#2
class Listen::Silencer
  # @return [Silencer] a new instance of Silencer
  #
  # source://listen//lib/listen/silencer.rb#57
  def initialize; end

  # source://listen//lib/listen/silencer.rb#61
  def configure(options); end

  # Returns the value of attribute ignore_patterns.
  #
  # source://listen//lib/listen/silencer.rb#55
  def ignore_patterns; end

  # Sets the attribute ignore_patterns
  #
  # @param value the value to set the attribute ignore_patterns to.
  #
  # source://listen//lib/listen/silencer.rb#55
  def ignore_patterns=(_arg0); end

  # Returns the value of attribute only_patterns.
  #
  # source://listen//lib/listen/silencer.rb#55
  def only_patterns; end

  # Sets the attribute only_patterns
  #
  # @param value the value to set the attribute only_patterns to.
  #
  # source://listen//lib/listen/silencer.rb#55
  def only_patterns=(_arg0); end

  # TODO: switch type and path places - and verify
  #
  # @return [Boolean]
  #
  # source://listen//lib/listen/silencer.rb#70
  def silenced?(relative_path, type); end

  private

  # source://listen//lib/listen/silencer.rb#84
  def _init_ignores(ignores, overrides); end

  # Returns the value of attribute options.
  #
  # source://listen//lib/listen/silencer.rb#82
  def options; end
end

# source://listen//lib/listen/silencer/controller.rb#3
class Listen::Silencer::Controller
  # @return [Controller] a new instance of Controller
  #
  # source://listen//lib/listen/silencer/controller.rb#4
  def initialize(silencer, default_options); end

  # source://listen//lib/listen/silencer/controller.rb#17
  def append_ignores(*regexps); end

  # source://listen//lib/listen/silencer/controller.rb#22
  def replace_with_bang_ignores(regexps); end

  # source://listen//lib/listen/silencer/controller.rb#26
  def replace_with_only(regexps); end

  private

  # source://listen//lib/listen/silencer/controller.rb#32
  def _reconfigure_silencer(extra_options); end
end

# The default list of directories that get ignored.
#
# source://listen//lib/listen/silencer.rb#4
Listen::Silencer::DEFAULT_IGNORED_DIRECTORIES = T.let(T.unsafe(nil), Regexp)

# The default list of files that get ignored.
#
# source://listen//lib/listen/silencer.rb#18
Listen::Silencer::DEFAULT_IGNORED_EXTENSIONS = T.let(T.unsafe(nil), Regexp)

# source://listen//lib/listen/version.rb#2
Listen::VERSION = T.let(T.unsafe(nil), String)
